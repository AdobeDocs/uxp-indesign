"use strict";(self.webpackChunkuxp_indesign=self.webpackChunkuxp_indesign||[]).push([[4863],{33944:function(e,t,n){n.r(t),n.d(t,{_frontmatter:function(){return r},default:function(){return m}});var o=n(87462),a=n(45987),s=(n(15007),n(64983)),i=n(91515);const l=["components"],r={},c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,s.mdx)("div",t)},p=c("CodeBlock"),d=c("InlineAlert"),u={_frontmatter:r},h=i.Z;function m(e){let{components:t}=e,n=(0,a.Z)(e,l);return(0,s.mdx)(h,(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.mdx)("h1",{id:"script-lifespan"},"Script lifespan"),(0,s.mdx)("p",null,"UXP scripts, like JavaScript, are single-threaded and non-blocking. It lives until the last statement in the execution stack."),(0,s.mdx)("p",null,"Let's understand this with a very simple example."),(0,s.mdx)(p,{slots:"heading, code",repeat:"2",languages:"JavaScript, Text",mdxType:"CodeBlock"}),(0,s.mdx)("h4",{id:"sampleidjs"},"sample.idjs"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre",className:"language-js"},'console.log("Start of execution.");\n\nfunction foo() {\n    console.log("Greetings: Hello");\n}\n\nfoo();\n\nconsole.log("End of execution.");\n')),(0,s.mdx)("h4",{id:"output"},"Output"),(0,s.mdx)("pre",null,(0,s.mdx)("code",{parentName:"pre"},"Start of execution\nGreetings: Hello\nEnd of execution\n")),(0,s.mdx)("p",null,'In the above code, the script is considered to be complete or done once it executes the last line. It is no longer alive after the last line - "End of execution". This is the standard way in which how JavaScript execution stack work. Learn about the ',(0,s.mdx)("a",{parentName:"p",href:"https://www.javascripttutorial.net/javascript-call-stack/"},"execution stack"),", if you are not already familiar with it. "),(0,s.mdx)(d,{variant:"info",slots:"text1, text2, text3",mdxType:"InlineAlert"}),(0,s.mdx)("p",null,(0,s.mdx)("strong",{parentName:"p"},"Pro tip")),(0,s.mdx)("p",null,"While debugging your scripts, adding a breakpoint to the last statement will help in seeing all the ",(0,s.mdx)("inlineCode",{parentName:"p"},"console.logs")," before they disappear when the script completes and debug window closes."),(0,s.mdx)("p",null,"It's also worth noting that a script session too coincides with its lifespan. Every execution is a different session. "),(0,s.mdx)("p",null,"The above example also showcases pure synchronous operations. Such operations are always executed sequentially."),(0,s.mdx)("p",null,"However, things are a little complicated when we speak about asynchronous tasks. An async task usually happens at a later point in time and the execution thread doesn't wait around for it to complete. (If you are not familiar with synchronous/asynchronous operations in JavaScript, here's an article that explains the ",(0,s.mdx)("a",{parentName:"p",href:"https://www.freecodecamp.org/news/synchronous-vs-asynchronous-in-javascript/"},"difference"),")"),(0,s.mdx)("p",null,"Since UXP scripts only live until it reaches the last statement in the call stack, they may no longer be alive, for the asynchronous tasks to execute at a later point in time. Almost as if it expects your code to be synchronous at all times."),(0,s.mdx)("p",null,"We understand that in real-world use cases, this is not possible. A network call is asynchronous and it may take a few seconds for it to resolve. And the script should wait for such operations somehow. So how do we handle such scenarios? By using ",(0,s.mdx)("inlineCode",{parentName:"p"},"global await"),", which makes asynchronous code behave like synchronous operations. We will learn about it in the next section."))}m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-scripts-concepts-script-lifespan-index-md-74aad108a65edb46f153.js.map